
<!DOCTYPE html>

<html class="no-js">

<head>
    <meta charset="utf-8">
    <title>A simple mobility simulation with GraphStream</title>
    <meta name="description" content="Technical presentation of the GraphStream Library">
    <meta name="author" content="The GraphStream Team">
    <meta name="viewport" content="width=device-width, maximum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="styles/prettify.css" type="text/css" rel="stylesheet" />
    <link href="styles/lecture.css" rel="stylesheet" type="text/css" />
    <script src="bower_components/jquery/jquery.js"></script>
</head>


<body>
    <div id="menu_handle" class="x2">»</div>
    <div id="menu" class="x-2">
        <ul></ul>
    </div>
    <div id="simple" data-template="mytemplate">


<!-- ============================================================== -->
<!-- ============================================================== -->
<!-- ============================================================== -->
    
    <div id="home" class="step">
    <h2>A simple mobility simulation with GraphStream</h2>
        <ul>
            <li>People with mobile communicating devices are moving in a given place.</li>
            <li>Their devices have a limited range of communication with others.</li>
            <li>Each time they are close enough, a connection is created to exchange data.</li>
            <li>This connection disappears as soon as they are too far.</li>
            <li><em>We use a graph to represent the devices as nodes and the connections as edges.</em></li>
        </ul>
        <p><div class="text_center"><img src="images/iPhone.png" width="15%" alt="an iPhone"/>&nbsp;&nbsp;<img src="images/Nexus5.jpg" width="15%" alt="a Nexus 5"/>&nbsp;&nbsp;<img src="images/Nokia.jpg" width="15%" alt="a Nokia lumia"/></div></p>
    </div>

    <div class="step">
    <h2>An ad-hoc network</h2>
        <ul>
            <li>The <em>ad-hoc</em> network created through this process is dynamic: links appear and disappear.</li>
            <li>It can be modeled by a <em>dynamic graph</em> where devices are nodes and communication links are edges.</li>
            <li>We will now model such mobile devices behavior and the resulting dynamic graph with <em>Java classes</em> using <em>GraphStream</em>.</li>
        </ul>
        <!--p><div class="text_center"><img src="images/exampleAdHoc.png" width="15%" alt="TODO"/></div></p-->
    </div>

    <div class="step">
    <h2>Random waypoint model</h2>
        <ul>
            <li>We will use the <em>“random waypoint”</em> mobility model:
                <ul>
                    <li>Each person equipped with a mobile device chooses a <em>random destination</em>,</li>
                    <li>Walks with a <em>random speed</em> toward it,</li>
                    <li>And stands still at this position for a <em>random time</em>.</li>
                </ul>
            </li>
        </ul>
        <br/>
        <p><div class="text_center"><img src="images/Mobility1.png" width="20%"/>&nbsp;&nbsp;&nbsp;<img src="images/Mobility2.png" width="20%"/>&nbsp;&nbsp;&nbsp;<img src="images/Mobility3.png" width="20%"/></div></p>
    </div>

    <div class="step">
    <h2>Implementation</h2>
    
        <p>We will use two Java classes:</p>
        
        <ul>
            <li><code>MobileDevice</code>, represents a moving person with a communication device,</li>
            <li><code>MobilitySimulation</code>, represents a set of persons and runs the simulation.</li>
        </ul>

        <p>We will start from these two classes that already implement a fully functional random waypoint
        simulation, and use GraphStream to represent the associated graph and make some measures on it.</p>

        <ul>
            <li>Open eclipse and find the <code>mobility</code> directory in the <code>gs-iccsa14</code> project,</li>
            <li>An open an editor on <code>MobilitySimulation</code>.</li>
        </ul>
    </div>

    <div class="step">
        <h2>The mobility simulation</h2>

        <p>The <code>MobilitySimulation</code> role is to register a set of <code>MobileDevice</code>
        objects and to run in a loop methods to make them move and to check which other mobile
        devices they can connect to.</p>

        <p>The principal methods are:</p>

        <ul>
            <li><code>MobilitySimulation()</code> the constructor, inits and runs the simulation.</li>
            <li><code>addMobileDevices()</code> registers a set of mobile devices in the simulation.</li>
            <li><code>moveMobileDevices()</code> makes each device move toward its target or wait.</li>
            <li><code>checkConnections()</code> sees toward which mobile devices connections can be made or removed</li>
        </ul>
    </div>

    <div class="step">
        <h2>The mobility simulation</h2>

        <p>The code is already in the tutorial, but incomplete, we will add a graph to represent the
        mobile device objects.</p>

        <p>We will add two lines in the constructor <code>MobilitySimulation</code> (in orange), note that we refer to a field <code>graph</code> that is already present:</p>

        <pre class="prettyprint lang-java">
public MobilitySimulation() {
    <span class="highlight">graph = new SingleGraph("mobility model");</span>
    <span class="highlight">graph.display(false);</span>
    addMobileDevices(deviceCount);
    initConnectedComponents();
    for(int step=0; step&lt;steps; step++) {
        moveMobileDevices();
        checkConnections();
        showConnectedComponents();
        sleep();
    }
}</pre>

        <!--p>This creates an empty graph and displays it.</p-->
    </div>

    <div class="step">
        <h2>The mobile devices</h2>

        <p>Now lets look at the <code>MobileDevice</code>. Here are the main methods:</p>

        <ul>
            <li><code>MobileDevice()</code> Builds a new mobile device knowing its name and the global graph.</li>
            <li><code>next()</code> Chooses the next action to do.</li>
            <li><code>closeTo()</code> True if the devices is close to another one.</li>
            <li><code>nextTarget()</code> Chooses a next target destination.</li>
            <li><code>move()</code> Move a little toward the target.</li>
            <li><code>atTarget()</code> True if arrived at target.</li>
            <li><code>checkConnections()</code> Check new connections or connections to remove.</li>
        </ul>
    </div>


    <div class="step">
        <h2>The mobile devices</h2>

        <p>We will also add one field and complete the constructor.</p>

        <p>Each device maps to a node in the global graph of the simulation:</p>

        <pre class="prettyprint lang-java">
<em>protected Node node;</em>
    
public MobileDevice(Graph graph, String name) {
    <span class="highlight">this.graph = graph;</span>
    this.x = Math.random();
    this.y = Math.random();
    nextTarget();
    <span class="highlight">node = graph.addNode(name);</span>
}</pre>
    </div>

    <div class="step">
        <h2>Specifying nodes position in the display</h2>

        <p>When the device moves, we must also tell the corresponding node representation
        in the display to move:</p>

        <pre class="prettyprint lang-java">
protected void move() {
    x += (targetx-x)*speed;     // Move a little (slow down at arrival).
    y += (targety-y)*speed;
    <span class="highlight">node.setAttribute("x", x);</span> 
    <span class="highlight">node.setAttribute("y", y);</span>
}</pre>

        <p>We use specific UI attributes to specify the abscissa and ordinate of the node.</p>
    </div>

    <div class="step">
        <h2>Fist test</h2>

        <p>We have a valid code, we can start to test.</p>

        <ul>
            <li>Only nodes will move.</li>
            <li>No edges will be drawn.</li>
        </ul>

        <br/>

        <h1><div class="text_center"><em>Try it !</em><div></h1>
    </div>

    <div class="step">
        <h2>Now lets add the connectivity !</h2>

        <p>We need first to know when a node is close to another.</p>

        <p>We could use the <code>x</code> and <code>y</code> of the mobile device, but to show you how it works, we will
        use the coordinates of the node in the graph we set previously in <code>move()</code>.</p>

        <p>Remove the code in the <code>closeTo()</code> method and change it with:</p>

        <pre class="prettyprint lang-java">
protected boolean closeTo(Node other) {
    <span class="highlight">double otherxy[] = nodePosition(other);</span>        
    <span class="highlight">return(Math.abs(x-otherxy[0]) < 0.07 && Math.abs(y-otherxy[1]) < 0.07);</span>
}</pre>

        <p><code>nodePosition()</code> is a static method in the <code>GraphPosLengthUtils</code>
        class that allows easy retrieval of the coordinate attributes in nodes. This class
        also allows to easily compute edges lengths for example.</p>
    </div>

    <div class="step">
        <h2>The connectivity</h2>

        <p>We will now check the connections to create or remove due to the displacement of
            devices.</p>

        <p>We will implement two sub-methods used by the <code>checkConnectivity()</code> method:</p>

        <pre class="prettyprint lang-java">
protected void checkConnections() {
    removeConnections();
    createConnections();
}</pre>
    </div>

    <div class="step">
        <h2>Removing connections</h2>

        <p>If a device moves too far away, the connections must disappear.</p>

        <pre class="prettyprint lang-java">
protected void removeConnections() {
    Iterator&lt;?extends Edge&gt; edges = node.getEdgeIterator();

    while(edges.hasNext()) {
        Edge edge = edges.next();
        if(!closeTo(edge.getOpposite(node))) {
            edges.remove();
        }
    }
}</pre>

        <p>We use an iterator on the set of edges of the graph, and get the opposite node
        of the edge. Using <code>closeTo()</code> we know if we must remove the edge with
        the iterator.</p>

        <p>Exercise: we could also have used <code>GraphPosLengthUtils.edgeLength()</code>.</p>
    </div>

    <div class="step">
        <h2>Creating connections</h2>

        <p>Now we will create connections for devices that are now close enough.</p>

        <pre class="prettyprint lang-java">
protected void createConnections() {
    for(Node other: graph) {
        if(other != node && closeTo(other)) {
            if(!node.hasEdgeToward(other.getId())) {
                graph.addEdge(
                    String.format("%s-%s", node.getId(), other.getId()),
                        node.getId(), other.getId());
            }
        }
    }
}</pre>

        <p>We iterate on each node of the graph. We then test if the node is not us, and if it is close
            enough. If so, we check if no edge already exist (<code>node.hasEdgeToward()</code>), and then create the new connection with
            <code>graph.addEdge()</code>.</p>
    </div>

    <div class="step">
        <h2>That's it !</h2>

        <h1><div class="text_center"><em>Try it !</em></div></h1>
    </div>

    <div class="step">
        <h2>Lets add a measure</h2>

        <p>We will add a dynamically updating measure on the graph: the number of connected components.
        We will also see how to add information on the graph, here the connected components count.</p>

        <p>First we add two fields, one for the display on the graph, called a <em>sprite</em>, the other
        for the algorithm that will observe the graph and constantly update the number of components:</p>

        <pre class="prettyprint lang-java">
protected Sprite cc;
protected ConnectedComponents ccalgo; </pre>

        <p>The <code>ConnectedComponents</code> class comes from the <code>gs-algo</code> package which
        contains lots of such algorithms.</p>
    </div>

    <div class="step">
        <h2>Initializing a dynamic algorithm</h2>

        <p>The connected components only need to know the graph. After this it will update
            itself each time the graph changes.</p>

        <p>We also use a <code>SpriteManager</code> to create a sprite, that is a graphical representation
            on the graph display, to add a label to print the number of connected components.</p>

        <pre class="prettyprint lang-java">
protected void initConnectedComponents() {
    ccalgo = new ConnectedComponents();
    ccalgo.init(graph);
    
    SpriteManager sm = new SpriteManager(graph);
    cc = sm.addSprite("cc");
    cc.setPosition(Units.PX, 10, 10, 0);
}</pre>
    </div>

    <div class="step">
        <h2>Displaying the connected components count</h2>

        <p>Now we display the measure, by updating the sprite at each simulation step:</p>

        <pre class="prettyprint lang-java">
protected void showConnectedComponents() {
    cc.setAttribute("ui.label", "Connected components " +
        ccalgo.getConnectedComponentsCount());
}</pre>
    </div>

    <div class="step">
        <h2>Adding some style</h2>

        <p>To make things more fancy, you can try adding a style sheet to the graph. In the
            <code>MobilitySimulation()</code> constructor, just after <code>graph.display()</code>,
            add:</p>

        <pre class="prettyprint lang-java">
...
graph.display(false);
<span class="highlight">graph.addAttribute("ui.antialias");</span>
<span class="highlight">graph.addAttribute("ui.stylesheet",
    "edge { fill-color: grey; } sprite { size: 0px; }");</span>
addMobileDevices(deviceCount);
...</pre>

        <h1><div class="text_center"><em>Try it !</em></div></h1>
    </div>

   <!-- ==== SLIDE ==== -->
   <div class="step" id="Slides_and_Material">
     <h2>Slides and Material</h2>
    <br><br><p>Get the Slides and Materials online:</p>
    <p>  <a href="http://graphstream-project.org/doc/Tutorials/Lab-Sessions/ICCSA-2014/">http://graphstream-project.org/doc/Tutorials/Lab-Sessions/ICCSA-2014/</a>

    <p>  <a href="https://github.com/graphstream/gs-talk/tree/iccsa2014">https://github.com/graphstream/gs-talk/tree/iccsa2014</a> (branch <code>iccsa2014</code>)
    </p>
  </div>


    </div> <!-- my template -->

    <script src="bower_components/jmpress/jmpress.js"></script>
    <script type="text/javascript" src="scripts/prettify.js"></script>
    <script type="text/javascript" src="scripts/lang-css.js"></script>
    <script type="text/javascript" src="scripts/lecture.js"></script>

</body>
</html>